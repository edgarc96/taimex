PicLan-IP/BASIC ^ ^
*
* GET_SO.XML - Sales Order retrieval (based on GET_PO2_PRODUCTION.XML)
*
OPEN 'XMLDATA' TO XMLDATAF ELSE STOP 201,'XMLDATA'
OPEN 'SO' TO SO2F ELSE STOP 201,'SO'
OPEN 'SHIPVIAS' TO SHIPVIASF ELSE STOP 201,'SHIPVIAS'
OPEN 'CUSTOMER' TO CUSTOMERF ELSE STOP 201,'CUSTOMER'

XVM = CHAR(253)
XSM = CHAR(252)
XAM = CHAR(254)
* Accept both uppercase and lowercase parameter names
PL_GETVAR SO_NUMBER FROM 'SO_NUMBER' ELSE SO_NUMBER = ''
IF SO_NUMBER = '' THEN
    PL_GETVAR SO_NUMBER FROM 'so_number' ELSE SO_NUMBER = ''
END
PL_ADD_HDR '"Content-Type: application/xml"'

XML.RESPONSE = '<?xml version="1.0" encoding="UTF-8"?><salesorders><so>'
XML.RESPONSE = XML.RESPONSE : '<!-- DEBUG_SO_NUMBER_RECEIVED: [' : SO_NUMBER : '] -->'

READ SO.RECORD FROM SO2F, SO_NUMBER ELSE
    XML.RESPONSE = XML.RESPONSE : '<error>SO not found</error></so></salesorders>'
    GOTO WRITE_RESPONSE
END

XML.RESPONSE = XML.RESPONSE : '<!-- DEBUG_SO_RECORD_FIELD1: [' : SO.RECORD<1> : '] -->'
XML.RESPONSE = XML.RESPONSE : '<!-- DEBUG_SO_RECORD_FIELD7: [' : SO.RECORD<7> : '] -->'
XML.RESPONSE = XML.RESPONSE : '<!-- DEBUG_SO_RECORD_FIELD8: [' : SO.RECORD<8> : '] -->'
XML.RESPONSE = XML.RESPONSE : '<!-- DEBUG_SO_RECORD_FIELD15: [' : SO.RECORD<15> : '] -->'

* Basic SO fields - NEW STRUCTURE: Position 2 = Ship To, Position 4 = Bill To
CUSTOMER_CODE = SO.RECORD<2>
BILLTO_CODE_HEADER = SO.RECORD<4>
* Convert SO date from Julian to calendar format (YYYY-MM-DD)
SO_DATE_JULIAN = SO.RECORD<1>
IF SO_DATE_JULIAN <> '' AND NUM(SO_DATE_JULIAN) THEN
    * Convert Julian to MM/DD/YYYY using D2/ format
    SO_DATE_TEMP = OCONV(SO_DATE_JULIAN, 'D2/')
    * Parse MM/DD/YYYY and convert to YYYY-MM-DD
    IF SO_DATE_TEMP <> '' AND INDEX(SO_DATE_TEMP, '/', 1) > 0 THEN
        MONTH_STR = SO_DATE_TEMP[1, INDEX(SO_DATE_TEMP, '/', 1) - 1]
        REST = SO_DATE_TEMP[INDEX(SO_DATE_TEMP, '/', 1) + 1, 999]
        DAY_STR = REST[1, INDEX(REST, '/', 1) - 1]
        YEAR_STR = REST[INDEX(REST, '/', 1) + 1, 999]
        * Ensure 4-digit year
        IF LEN(YEAR_STR) = 2 THEN YEAR_STR = '20' : YEAR_STR
        * Pad month and day with zeros if needed
        IF LEN(MONTH_STR) = 1 THEN MONTH_STR = '0' : MONTH_STR
        IF LEN(DAY_STR) = 1 THEN DAY_STR = '0' : DAY_STR
        SO_DATE_CALENDAR = YEAR_STR : '-' : MONTH_STR : '-' : DAY_STR
    END ELSE
        SO_DATE_CALENDAR = ''
    END
END ELSE
    SO_DATE_CALENDAR = ''
END
XML.RESPONSE = XML.RESPONSE : '<so_number>' : SO_NUMBER : '</so_number>'
XML.RESPONSE = XML.RESPONSE : '<so_date>' : SO_DATE_CALENDAR : '</so_date>'
XML.RESPONSE = XML.RESPONSE : '<po_date>' : SO_DATE_CALENDAR : '</po_date>'
XML.RESPONSE = XML.RESPONSE : '<salesperson>' : SO.RECORD<8> : '</salesperson>'
XML.RESPONSE = XML.RESPONSE : '<customer_number>' : CUSTOMER_CODE : '</customer_number>'
XML.RESPONSE = XML.RESPONSE : '<billto_code_header>' : BILLTO_CODE_HEADER : '</billto_code_header>'
XML.RESPONSE = XML.RESPONSE : '<so_status>' : SO.RECORD<15> : '</so_status>'
XML.RESPONSE = XML.RESPONSE : '<ship_via>' : SO.RECORD<11> : '</ship_via>'
XML.RESPONSE = XML.RESPONSE : '<terms>' : SO.RECORD<18> : '</terms>'
XML.RESPONSE = XML.RESPONSE : '<email>' : SO.RECORD<27,1> : '</email>'
XML.RESPONSE = XML.RESPONSE : '<po_number>' : SO.RECORD<7> : '</po_number>'
* Carrier Account - Position 59 for UPS, 76 for others
CARRIER_ACCOUNT = SO.RECORD<59>
IF CARRIER_ACCOUNT = '' THEN CARRIER_ACCOUNT = SO.RECORD<76>
XML.RESPONSE = XML.RESPONSE : '<carrier_account>' : CARRIER_ACCOUNT : '</carrier_account>'

* Ship Via info - Read name from SHIPVIAS database
SHIPVIA_CODE = SO.RECORD<11>
SHIPVIA_NAME = ''
SHIPVIA_DESC = ''

IF SHIPVIA_CODE <> '' THEN
    * Try exact match first
    READ SHIPVIA.RECORD FROM SHIPVIASF, SHIPVIA_CODE ELSE
        * If exact match fails, try to extract main part (before space or parentheses)
        SHIPVIA_SHORT = SHIPVIA_CODE
        IF INDEX(SHIPVIA_SHORT, ' ', 1) > 0 THEN
            SHIPVIA_SHORT = FIELD(SHIPVIA_SHORT, ' ', 1)
        END
        IF INDEX(SHIPVIA_SHORT, '(', 1) > 0 THEN
            SHIPVIA_SHORT = FIELD(SHIPVIA_SHORT, '(', 1)
        END
        
        * Try lookup with shortened code
        READ SHIPVIA.RECORD FROM SHIPVIASF, SHIPVIA_SHORT ELSE SHIPVIA.RECORD = ''
        
        * Debug what we're trying to lookup
        IF SHIPVIA.RECORD <> '' THEN
            FOUND_STATUS = 'YES'
        END ELSE
            FOUND_STATUS = 'NO'
        END
        XML.RESPONSE = XML.RESPONSE : '<!-- DEBUG_SHIPVIA_LOOKUP: ORIGINAL=' : SHIPVIA_CODE : ' SHORTENED=' : SHIPVIA_SHORT : ' FOUND=' : FOUND_STATUS : ' -->'
    END
END

* Process the result regardless of which lookup succeeded
IF SHIPVIA_CODE <> '' AND SHIPVIA.RECORD <> '' THEN
    SHIPVIA_NAME = SHIPVIA.RECORD<1>
    SHIPVIA_DESC = SHIPVIA.RECORD<2>
END

* Always output the fields (even if empty)
XML.RESPONSE = XML.RESPONSE : '<ship_via_name>' : SHIPVIA_NAME : '</ship_via_name>'
XML.RESPONSE = XML.RESPONSE : '<ship_via_description>' : SHIPVIA_DESC : '</ship_via_description>'

* Vendor info - NEW STRUCTURE: Ship To in position 2, Bill To in position 4
CUSTOMER_NUM = SO.RECORD<2>
IF CUSTOMER_NUM = '' THEN CUSTOMER_NUM = SO.RECORD<4>
IF CUSTOMER_NUM = '' THEN CUSTOMER_NUM = SO.RECORD<7>
IF CUSTOMER_NUM = '' THEN CUSTOMER_NUM = SO.RECORD<13>
XML.RESPONSE = XML.RESPONSE : '<customer_info><customer_code>' : CUSTOMER_NUM : '</customer_code>'
IF CUSTOMER_NUM <> '' THEN
    READ CUSTOMER.RECORD FROM CUSTOMERF, CUSTOMER_NUM ELSE CUSTOMER.RECORD = ''
    IF CUSTOMER.RECORD <> '' THEN
        * Customer Number should be the CODE (from SO position 2), not the name
        * This displays in the "Número:" field in Ship To box
        XML.RESPONSE = XML.RESPONSE : '<customer_number>' : CUSTOMER_NUM : '</customer_number>'
        * Try different fields for real city name
        V_CITY = CUSTOMER.RECORD<3>
        IF V_CITY = '' OR NUM(V_CITY) THEN
            V_CITY = CUSTOMER.RECORD<2>
            * If address2 contains city info, extract it
            IF INDEX(V_CITY, ',', 1) > 0 THEN
                V_CITY = FIELD(V_CITY, ',', 2)
                V_CITY = TRIM(V_CITY)
            END
        END
        
        * Clean any remaining codes from city
        IF INDEX(V_CITY, '*', 1) > 0 THEN V_CITY = FIELD(V_CITY, '*', 1)
        
        V_STATE = CUSTOMER.RECORD<5>  
        IF INDEX(V_STATE, '*', 1) > 0 THEN V_STATE = FIELD(V_STATE, '*', 1)
        
        * Get Bill To from position 10 of Customer record
        BILL_TO_CODE = CUSTOMER.RECORD<10>
        BILL_TO_NAME = ''
        IF BILL_TO_CODE <> '' THEN
            IF INDEX(BILL_TO_CODE, '*', 1) > 0 THEN BILL_TO_CODE = FIELD(BILL_TO_CODE, '*', 1)
            READ BILL_TO.RECORD FROM CUSTOMERF, BILL_TO_CODE ELSE BILL_TO.RECORD = ''
            IF BILL_TO.RECORD <> '' THEN
                BILL_TO_NAME = BILL_TO.RECORD<1>
            END
        END
        
        V_CONTACT = CUSTOMER.RECORD<10>
        IF INDEX(V_CONTACT, '*', 1) > 0 THEN V_CONTACT = FIELD(V_CONTACT, '*', 1)
        
        XML.RESPONSE = XML.RESPONSE : '<customer_name>' : CUSTOMER.RECORD<1> : '</customer_name>'
        XML.RESPONSE = XML.RESPONSE : '<bill_to_code>' : BILL_TO_CODE : '</bill_to_code>'
        XML.RESPONSE = XML.RESPONSE : '<bill_to_name>' : BILL_TO_NAME : '</bill_to_name>'
        * Clean address fields
        CLEAN_STR = CUSTOMER.RECORD<2>
        GOSUB CLEAN_TEXT
        XML.RESPONSE = XML.RESPONSE : '<customer_address1>' : CLEAN_STR : '</customer_address1>'
        CLEAN_STR = CUSTOMER.RECORD<3>
        GOSUB CLEAN_TEXT
        XML.RESPONSE = XML.RESPONSE : '<customer_address2>' : CLEAN_STR : '</customer_address2>'
        XML.RESPONSE = XML.RESPONSE : '<customer_city>' : V_CITY : '</customer_city>'
        XML.RESPONSE = XML.RESPONSE : '<customer_state>' : V_STATE : '</customer_state>'
        XML.RESPONSE = XML.RESPONSE : '<customer_zip>' : CUSTOMER.RECORD<6> : '</customer_zip>'
        XML.RESPONSE = XML.RESPONSE : '<customer_country>' : CUSTOMER.RECORD<7> : '</customer_country>'
        XML.RESPONSE = XML.RESPONSE : '<customer_contact>' : V_CONTACT : '</customer_contact>'
        XML.RESPONSE = XML.RESPONSE : '<customer_phone>' : CUSTOMER.RECORD<9> : '</customer_phone>'
        XML.RESPONSE = XML.RESPONSE : '<customer_email>' : CUSTOMER.RECORD<10> : '</customer_email>'
    END
    IF CUSTOMER.RECORD = '' THEN
        XML.RESPONSE = XML.RESPONSE : '<customer_name></customer_name><customer_address1></customer_address1><customer_address2></customer_address2><customer_city></customer_city><customer_state></customer_state><customer_zip></customer_zip><customer_country></customer_country><customer_contact></customer_contact><customer_phone></customer_phone><customer_email></customer_email>'
    END
END
IF CUSTOMER_NUM = '' THEN
    XML.RESPONSE = XML.RESPONSE : '<customer_name></customer_name><customer_address1></customer_address1><customer_address2></customer_address2><customer_city></customer_city><customer_state></customer_state><customer_zip></customer_zip><customer_country></customer_country><customer_contact></customer_contact><customer_phone></customer_phone><customer_email></customer_email>'
END
XML.RESPONSE = XML.RESPONSE : '</customer_info>'

* Ship-to info with full address lookup
SHIPTO_CODE = SO.RECORD<4>
IF SHIPTO_CODE = '' THEN SHIPTO_CODE = SO.RECORD<2>
IF SHIPTO_CODE = '' THEN SHIPTO_CODE = SO.RECORD<3>
IF SHIPTO_CODE = '' THEN SHIPTO_CODE = SO.RECORD<6>

XML.RESPONSE = XML.RESPONSE : '<shipto_info><shipto_number>' : SHIPTO_CODE : '</shipto_number>'
IF SHIPTO_CODE <> '' THEN
    READ SHIPTO.RECORD FROM CUSTOMERF, SHIPTO_CODE ELSE SHIPTO.RECORD = ''
    IF SHIPTO.RECORD <> '' THEN
        * Try to get real city name from address fields
        S_CITY = SHIPTO.RECORD<3>
        IF S_CITY = '' OR NUM(S_CITY) THEN
            S_CITY = SHIPTO.RECORD<2>
            * If address contains city, extract it
            IF INDEX(S_CITY, ',', 1) > 0 THEN
                CITY_PARTS = DCOUNT(S_CITY, ',')
                IF CITY_PARTS >= 2 THEN
                    S_CITY = FIELD(S_CITY, ',', CITY_PARTS - 1)
                    S_CITY = TRIM(S_CITY)
                END
            END
        END
        
        * Clean shipto data by taking first part before '*'
        IF INDEX(S_CITY, '*', 1) > 0 THEN S_CITY = FIELD(S_CITY, '*', 1)
        
        S_STATE = SHIPTO.RECORD<5>
        IF INDEX(S_STATE, '*', 1) > 0 THEN S_STATE = FIELD(S_STATE, '*', 1)
        
        S_ZIP = SHIPTO.RECORD<6>
        IF INDEX(S_ZIP, '*', 1) > 0 THEN S_ZIP = FIELD(S_ZIP, '*', 1)
        
        XML.RESPONSE = XML.RESPONSE : '<shipto_name>' : SHIPTO.RECORD<1> : '</shipto_name>'
        XML.RESPONSE = XML.RESPONSE : '<name>' : SHIPTO.RECORD<1> : '</name>'
        * Clean shipto address fields
        CLEAN_STR = SHIPTO.RECORD<2>
        GOSUB CLEAN_TEXT
        XML.RESPONSE = XML.RESPONSE : '<shipto_address1>' : CLEAN_STR : '</shipto_address1>'
        XML.RESPONSE = XML.RESPONSE : '<address1>' : CLEAN_STR : '</address1>'
        CLEAN_STR = SHIPTO.RECORD<3>
        GOSUB CLEAN_TEXT
        XML.RESPONSE = XML.RESPONSE : '<shipto_address2>' : CLEAN_STR : '</shipto_address2>'
        XML.RESPONSE = XML.RESPONSE : '<address2>' : CLEAN_STR : '</address2>'
        XML.RESPONSE = XML.RESPONSE : '<shipto_city>' : S_CITY : '</shipto_city>'
        XML.RESPONSE = XML.RESPONSE : '<city>' : S_CITY : '</city>'
        XML.RESPONSE = XML.RESPONSE : '<shipto_state>' : S_STATE : '</shipto_state>'
        XML.RESPONSE = XML.RESPONSE : '<state>' : S_STATE : '</state>'
        XML.RESPONSE = XML.RESPONSE : '<shipto_zip>' : S_ZIP : '</shipto_zip>'
        XML.RESPONSE = XML.RESPONSE : '<zip>' : S_ZIP : '</zip>'
    END
    IF SHIPTO.RECORD = '' THEN
        XML.RESPONSE = XML.RESPONSE : '<shipto_name></shipto_name><name></name>'
        XML.RESPONSE = XML.RESPONSE : '<shipto_address1></shipto_address1><address1></address1>'
        XML.RESPONSE = XML.RESPONSE : '<shipto_address2></shipto_address2><address2></address2>'
        XML.RESPONSE = XML.RESPONSE : '<shipto_city></shipto_city><city></city>'
        XML.RESPONSE = XML.RESPONSE : '<shipto_state></shipto_state><state></state>'
        XML.RESPONSE = XML.RESPONSE : '<shipto_zip></shipto_zip><zip></zip>'
    END
END
IF SHIPTO_CODE = '' THEN
    XML.RESPONSE = XML.RESPONSE : '<shipto_name></shipto_name><name></name>'
    XML.RESPONSE = XML.RESPONSE : '<shipto_address1></shipto_address1><address1></address1>'
    XML.RESPONSE = XML.RESPONSE : '<shipto_address2></shipto_address2><address2></address2>'
    XML.RESPONSE = XML.RESPONSE : '<shipto_city></shipto_city><city></city>'
    XML.RESPONSE = XML.RESPONSE : '<shipto_state></shipto_state><state></state>'
    XML.RESPONSE = XML.RESPONSE : '<shipto_zip></shipto_zip><zip></zip>'
END
XML.RESPONSE = XML.RESPONSE : '</shipto_info>'

* Bill To info - Read directly from position 4
BILLTO_CODE_DIRECT = SO.RECORD<4>
IF BILLTO_CODE_DIRECT <> '' THEN
    XML.RESPONSE = XML.RESPONSE : '<billto_code_direct>' : BILLTO_CODE_DIRECT : '</billto_code_direct>'
END ELSE
    XML.RESPONSE = XML.RESPONSE : '<billto_code_direct></billto_code_direct>'
END

* Line items - CORRECTED POSITIONS FROM SOCHG
LINE_ITEMS = SO.RECORD<31>
PART_NUMS = SO.RECORD<32>
DESCRIPTIONS = SO.RECORD<33>
QUANTITIES = SO.RECORD<35>
PRICES = SO.RECORD<36>
UOMS = SO.RECORD<37>

* Get tracking data - CORRECTED POSITIONS
SCHED_RAW = SO.RECORD<34>
NEEDS_RAW = SO.RECORD<38>
ACK_RAW = SO.RECORD<49>

* DEBUG: Check field values
XML.RESPONSE = XML.RESPONSE : '<!-- DEBUG FIELD 31: [' : LINE_ITEMS : '] -->'
XML.RESPONSE = XML.RESPONSE : '<!-- DEBUG FIELD 32: [' : PART_NUMS : '] -->'

XML.RESPONSE = XML.RESPONSE : '<line_items>'
IF LINE_ITEMS <> '' THEN
    * CRITICAL DEBUG: Check what character is actually used as separator
    XML.RESPONSE = XML.RESPONSE : '<!-- DEBUG LINE_ITEMS LENGTH: ' : LEN(LINE_ITEMS) : ' -->'
    FOR DEBUG_IDX = 1 TO LEN(LINE_ITEMS)
        CHAR_CODE = SEQ(LINE_ITEMS[DEBUG_IDX,1])
        XML.RESPONSE = XML.RESPONSE : '<!-- DEBUG CHAR ' : DEBUG_IDX : ': ASCII=' : CHAR_CODE : ' -->'
    NEXT DEBUG_IDX
    
    * CHAR(253) works natively with DCOUNT and FIELD - no conversion needed
    LINE_COUNT = DCOUNT(LINE_ITEMS, XVM)
    XML.RESPONSE = XML.RESPONSE : '<!-- DEBUG LINE_COUNT NATIVE XVM: ' : LINE_COUNT : ' -->'
    
    * Field 49 should already contain CHAR(252) and CHAR(253) only - no conversion needed
    TEMP_ACK_RAW = ACK_RAW
    XML.RESPONSE = XML.RESPONSE : '<!-- RAW_ACK_FIELD49: [' : ACK_RAW : '] -->'
    
    * REMOVED: All conversion logic - data should already have CHAR(252) and CHAR(253)
    
    XML.RESPONSE = XML.RESPONSE : '<!-- CONVERTED_ACK_RAW: [' : TEMP_ACK_RAW : '] -->'
    XML.RESPONSE = XML.RESPONSE : '<!-- MULTIVALUE_COUNT_AFTER: [' : DCOUNT(TEMP_ACK_RAW, XVM) : '] -->'
    
    FOR I = 1 TO LINE_COUNT
        XML.RESPONSE = XML.RESPONSE : '<line_item>'
        XML.RESPONSE = XML.RESPONSE : '<!-- DEBUG LINE ' : I : ' of ' : LINE_COUNT : ' -->'
        
        LINE_CODE = FIELD(LINE_ITEMS, XVM, I)
        PART_NUM = FIELD(PART_NUMS, XVM, I)
        RAW_QTY_VAL = FIELD(QUANTITIES, XVM, I)
        DESC_VAL = FIELD(DESCRIPTIONS, XVM, I)
        RAW_PRICE_VAL = FIELD(PRICES, XVM, I)
        
        * MR4 CONVERSION: Convert internal format to display format (4 decimal places)
        * Internal: 200000, Display: 20.0000
        * MR4 automatically divides by 10000 for 4 decimal places
        * Formula: display = OCONV(internal, 'MR4')
        IF RAW_PRICE_VAL <> '' AND NUM(RAW_PRICE_VAL) THEN
            NUMERIC_VAL = RAW_PRICE_VAL + 0
            * Use OCONV with MR4 - it handles the division automatically
            PRICE_VAL = OCONV(NUMERIC_VAL, 'MR4')
        END ELSE
            PRICE_VAL = '0.0000'
        END
        
        * CRITICAL FIX: Clean quantity field that contains multivalue corruption
        QTY_VAL = RAW_QTY_VAL
        IF INDEX(QTY_VAL, XSM, 1) > 0 THEN
            QTY_VAL = FIELD(QTY_VAL, XSM, 1)
        END
        IF INDEX(QTY_VAL, XVM, 1) > 0 THEN
            QTY_VAL = FIELD(QTY_VAL, XVM, 1)
        END
        * Remove any date contamination like "2\21089"
        IF INDEX(QTY_VAL, '\', 1) > 0 THEN
            QTY_VAL = FIELD(QTY_VAL, '\', 1)
        END
        QTY_VAL = TRIM(QTY_VAL)
        
        * CLEAN part number - remove any CHAR(252) or CHAR(253) separators
        CLEAN_PART_NUM = PART_NUM
        IF INDEX(CLEAN_PART_NUM, XSM, 1) > 0 THEN
            CLEAN_PART_NUM = FIELD(CLEAN_PART_NUM, XSM, 1)
        END
        IF INDEX(CLEAN_PART_NUM, XVM, 1) > 0 THEN
            CLEAN_PART_NUM = FIELD(CLEAN_PART_NUM, XVM, 1)
        END
        
        * Price already converted by MR4 - use it directly as FINAL_PRICE_VAL
        FINAL_PRICE_VAL = PRICE_VAL
        
        XML.RESPONSE = XML.RESPONSE : '<!-- DEBUG LINE_CODE: [' : LINE_CODE : '] -->'
        XML.RESPONSE = XML.RESPONSE : '<!-- RAW_PART_NUM: [' : PART_NUM : '] CLEAN_PART_NUM: [' : CLEAN_PART_NUM : '] -->'
        XML.RESPONSE = XML.RESPONSE : '<!-- RAW_PRICE_INTERNAL: [' : RAW_PRICE_VAL : '] FINAL_PRICE_DISPLAY: [' : FINAL_PRICE_VAL : '] -->'
        XML.RESPONSE = XML.RESPONSE : '<line_item_code>' : LINE_CODE : '</line_item_code>'
        XML.RESPONSE = XML.RESPONSE : '<part_number>' : CLEAN_PART_NUM : '</part_number>'
        
        IF DESC_VAL = '' THEN DESC_VAL = PART_NUM
        XML.RESPONSE = XML.RESPONSE : '<description>' : DESC_VAL : '</description>'
        
        XML.RESPONSE = XML.RESPONSE : '<quantity>' : QTY_VAL : '</quantity>'
        XML.RESPONSE = XML.RESPONSE : '<unit_price>' : FINAL_PRICE_VAL : '</unit_price>'
        
        * Extract UOM (Unit of Measure) for this line item
        UOM_VAL = FIELD(UOMS, XVM, I)
        IF UOM_VAL <> '' THEN
            XML.RESPONSE = XML.RESPONSE : '<uom>' : UOM_VAL : '</uom>'
        END ELSE
            XML.RESPONSE = XML.RESPONSE : '<uom>EA</uom>'
        END
        
        * Add tracking data per line item - Using pre-converted TEMP_ACK_RAW
        
        LINE_NEED = FIELD(NEEDS_RAW, XVM, I)
        LINE_ACK = FIELD(TEMP_ACK_RAW, XVM, I)
        LINE_SCHED = FIELD(SCHED_RAW, XVM, I)
        XML.RESPONSE = XML.RESPONSE : '<!-- LINE_ACK for line ' : I : ': [' : LINE_ACK : '] -->'
        
        
        * Need entries for this line (all subvalues) - CLEANED
        XML.RESPONSE = XML.RESPONSE : '<need_entries>'
        IF LINE_NEED <> '' THEN
            * Clean the entire line need data first
            CONVERT 'ý' TO '' IN LINE_NEED
            CONVERT 'Ã' TO '' IN LINE_NEED
            CONVERT CHAR(13) TO '' IN LINE_NEED
            CONVERT CHAR(10) TO '' IN LINE_NEED
            
            NEED_SUB_COUNT = DCOUNT(LINE_NEED, XSM)
            IF NEED_SUB_COUNT = 0 THEN NEED_SUB_COUNT = 1
            FOR N = 1 TO NEED_SUB_COUNT
                NEED_SUB = FIELD(LINE_NEED, XSM, N)
                IF NEED_SUB <> '' THEN
                    NEED_DATE_VAL = FIELD(NEED_SUB, '*', 1)
                    NEED_QTY_VAL = FIELD(NEED_SUB, '*', 2)
                    
                    * CRITICAL FIX: Clean need date from line index prefix
                    IF INDEX(NEED_DATE_VAL, ':', 1) > 0 THEN
                        NEED_DATE_VAL = FIELD(NEED_DATE_VAL, ':', 2)
                    END
                    
                    * Clean the quantity value completely
                    IF INDEX(NEED_QTY_VAL, '2025', 1) > 0 THEN
                        NEED_QTY_VAL = FIELD(NEED_QTY_VAL, '2025', 1)
                    END
                    IF INDEX(NEED_QTY_VAL, '-', 1) > 0 THEN
                        NEED_QTY_VAL = FIELD(NEED_QTY_VAL, '-', 1)  
                    END
                    IF INDEX(NEED_QTY_VAL, '\', 1) > 0 THEN
                        NEED_QTY_VAL = FIELD(NEED_QTY_VAL, '\', 1)
                    END
                    NEED_QTY_VAL = TRIM(NEED_QTY_VAL)
                    
                    XML.RESPONSE = XML.RESPONSE : '<need_entry>'
                    XML.RESPONSE = XML.RESPONSE : '<need_date>' : NEED_DATE_VAL : '</need_date>'
                    XML.RESPONSE = XML.RESPONSE : '<need_qty>' : NEED_QTY_VAL : '</need_qty>'
                    XML.RESPONSE = XML.RESPONSE : '</need_entry>'
                END
            NEXT N
        END
        XML.RESPONSE = XML.RESPONSE : '</need_entries>'
        
        * Legacy single need fields for backwards compatibility
        FIRST_NEED = FIELD(LINE_NEED, XSM, 1)
        NEED_DATE_VAL = FIELD(FIRST_NEED, '*', 1)
        NEED_QTY_VAL = FIELD(FIRST_NEED, '*', 2)
        
        * CRITICAL FIX: Clean need date from line index prefix
        IF INDEX(NEED_DATE_VAL, ':', 1) > 0 THEN
            NEED_DATE_VAL = FIELD(NEED_DATE_VAL, ':', 2)
        END
        
        * CRITICAL FIX: Clean need quantity from date contamination
        IF INDEX(NEED_QTY_VAL, '2025', 1) > 0 THEN
            NEED_QTY_VAL = FIELD(NEED_QTY_VAL, '2025', 1)
        END
        IF INDEX(NEED_QTY_VAL, '-', 1) > 0 THEN
            NEED_QTY_VAL = FIELD(NEED_QTY_VAL, '-', 1)  
        END
        IF INDEX(NEED_QTY_VAL, '\', 1) > 0 THEN
            NEED_QTY_VAL = FIELD(NEED_QTY_VAL, '\', 1)
        END
        NEED_QTY_VAL = TRIM(NEED_QTY_VAL)
        
        XML.RESPONSE = XML.RESPONSE : '<need_date>' : NEED_DATE_VAL : '</need_date>'
        XML.RESPONSE = XML.RESPONSE : '<need_qty>' : NEED_QTY_VAL : '</need_qty>'
        
        * Ack entries for this line (all subvalues)
        XML.RESPONSE = XML.RESPONSE : '<ack_entries>'
        IF LINE_ACK <> '' THEN
            XML.RESPONSE = XML.RESPONSE : '<!-- RAW_LINE_ACK: [' : LINE_ACK : '] -->'
            
            * LINE_ACK should ONLY contain CHAR(252) and CHAR(253) - no conversion needed
            TEMP_LINE_ACK = LINE_ACK
            XML.RESPONSE = XML.RESPONSE : '<!-- USING_RAW_LINE_ACK_WITH_CHAR252_CHAR253_ONLY -->'
            
            ACK_SUB_COUNT = DCOUNT(TEMP_LINE_ACK, XSM)
            IF ACK_SUB_COUNT = 0 THEN ACK_SUB_COUNT = 1
            XML.RESPONSE = XML.RESPONSE : '<!-- ACK_SUB_COUNT for line ' : I : ': [' : ACK_SUB_COUNT : '] -->'
            FOR A = 1 TO ACK_SUB_COUNT
                ACK_SUB = FIELD(TEMP_LINE_ACK, XSM, A)
                IF ACK_SUB <> '' THEN
                    ACK_DATE_VAL = FIELD(ACK_SUB, '*', 1)
                    ACK_QTY_VAL = FIELD(ACK_SUB, '*', 2)
                    
                    * CRITICAL FIX: Clean ack date from line index prefix like "2:3:3:21090"
                    IF INDEX(ACK_DATE_VAL, ':', 1) > 0 THEN
                        * Extract the last part after the final colon
                        COLON_COUNT = DCOUNT(ACK_DATE_VAL, ':')
                        ACK_DATE_VAL = FIELD(ACK_DATE_VAL, ':', COLON_COUNT)
                    END
                    
                    * Clean quantity by extracting only digits
                    CLEAN_ACK_QTY = ''
                    IF ACK_QTY_VAL <> '' THEN
                        ACK_QTY_LEN = LEN(ACK_QTY_VAL)
                        FOR ACK_I = 1 TO ACK_QTY_LEN
                            ACK_CHAR = ACK_QTY_VAL[ACK_I,1]
                            IF ACK_CHAR >= '0' AND ACK_CHAR <= '9' THEN
                                CLEAN_ACK_QTY = CLEAN_ACK_QTY : ACK_CHAR
                            END
                            IF ACK_CHAR < '0' OR ACK_CHAR > '9' THEN ACK_I = ACK_QTY_LEN
                        NEXT ACK_I
                        IF CLEAN_ACK_QTY <> '' THEN ACK_QTY_VAL = CLEAN_ACK_QTY
                    END
                    
                    XML.RESPONSE = XML.RESPONSE : '<ack_entry>'
                    XML.RESPONSE = XML.RESPONSE : '<ack_date>' : ACK_DATE_VAL : '</ack_date>'
                    XML.RESPONSE = XML.RESPONSE : '<ack_qty>' : ACK_QTY_VAL : '</ack_qty>'
                    XML.RESPONSE = XML.RESPONSE : '<line_position>' : I : '</line_position>'
                    XML.RESPONSE = XML.RESPONSE : '</ack_entry>'
                END
            NEXT A
        END
        XML.RESPONSE = XML.RESPONSE : '</ack_entries>'
        
        * Legacy single ack fields for backwards compatibility
        FIRST_ACK = FIELD(LINE_ACK, XSM, 1)
        ACK_DATE_VAL = FIELD(FIRST_ACK, '*', 1)
        ACK_QTY_VAL = FIELD(FIRST_ACK, '*', 2)
        
        * CRITICAL FIX: Clean ack date from line index prefix like "2:3:3:21090"
        IF INDEX(ACK_DATE_VAL, ':', 1) > 0 THEN
            * Extract the last part after the final colon
            COLON_COUNT = DCOUNT(ACK_DATE_VAL, ':')
            ACK_DATE_VAL = FIELD(ACK_DATE_VAL, ':', COLON_COUNT)
        END
        
        * Clean the legacy quantity too
        CLEAN_ACK_QTY = ''
        IF ACK_QTY_VAL <> '' THEN
            ACK_QTY_LEN = LEN(ACK_QTY_VAL)
            FOR ACK_I = 1 TO ACK_QTY_LEN
                ACK_CHAR = ACK_QTY_VAL[ACK_I,1]
                IF ACK_CHAR >= '0' AND ACK_CHAR <= '9' THEN
                    CLEAN_ACK_QTY = CLEAN_ACK_QTY : ACK_CHAR
                END
                IF ACK_CHAR < '0' OR ACK_CHAR > '9' THEN ACK_I = ACK_QTY_LEN
            NEXT ACK_I
            IF CLEAN_ACK_QTY <> '' THEN ACK_QTY_VAL = CLEAN_ACK_QTY
        END
        XML.RESPONSE = XML.RESPONSE : '<ack_date>' : ACK_DATE_VAL : '</ack_date>'
        XML.RESPONSE = XML.RESPONSE : '<ack_qty>' : ACK_QTY_VAL : '</ack_qty>'
        
        * Schedule entries for this line - MINIMAL PROCESSING TO PRESERVE DATA
        XML.RESPONSE = XML.RESPONSE : '<schedule_entries>'
        IF LINE_SCHED <> '' THEN
            * Minimal cleaning - only remove control characters, keep structure intact
            TEMP_LINE_SCHED = LINE_SCHED
            CONVERT CHAR(0) TO '' IN TEMP_LINE_SCHED
            CONVERT CHAR(1) TO '' IN TEMP_LINE_SCHED
            CONVERT CHAR(2) TO '' IN TEMP_LINE_SCHED
            TEMP_LINE_SCHED = TRIM(TEMP_LINE_SCHED)
            
            SCHED_SUB_COUNT = DCOUNT(TEMP_LINE_SCHED, XSM)
            IF SCHED_SUB_COUNT = 0 AND TEMP_LINE_SCHED <> '' THEN SCHED_SUB_COUNT = 1
            
            * Process each entry in exact order without aggressive cleaning
            FOR J = 1 TO SCHED_SUB_COUNT
                SCHED_ITEM = FIELD(TEMP_LINE_SCHED, XSM, J)
                IF SCHED_ITEM <> '' THEN
                    SCHED_DATE_VAL = FIELD(SCHED_ITEM, '*', 1)
                    SCHED_QTY_VAL = FIELD(SCHED_ITEM, '*', 2)
                    
                    * CRITICAL: Filter out invalid Julian dates like "1", "0", etc. (SAME AS GLOBAL)
                    SKIP_INVALID_LINE_DATE = 0
                    IF NUM(SCHED_DATE_VAL) AND SCHED_DATE_VAL <> '' THEN
                        IF SCHED_DATE_VAL < 365 THEN
                            SKIP_INVALID_LINE_DATE = 1
                            * Debug: Log filtered dates in line items
                            XML.RESPONSE = XML.RESPONSE : '<!-- LINE ITEM FILTERED INVALID DATE: ' : SCHED_DATE_VAL : ' -->'
                        END
                    END
                    
                    * Only process valid dates in line items
                    IF SKIP_INVALID_LINE_DATE = 0 THEN
                        * Minimal cleaning for quantity - preserve ALL numeric values
                        IF SCHED_QTY_VAL <> '' THEN
                            SCHED_QTY_VAL = TRIM(SCHED_QTY_VAL)
                            * ONLY remove obvious Julian date corruption, nothing else
                            IF LEN(SCHED_QTY_VAL) > 5 AND INDEX(SCHED_QTY_VAL, '20994', 1) > 0 THEN
                                TEMP_QTY = FIELD(SCHED_QTY_VAL, '20994', 1)
                                IF TEMP_QTY <> '' AND NUM(TEMP_QTY) THEN 
                                    SCHED_QTY_VAL = TEMP_QTY
                                END
                            END
                        END
                        
                        XML.RESPONSE = XML.RESPONSE : '<schedule_entry>'
                        XML.RESPONSE = XML.RESPONSE : '<schedule_date>' : SCHED_DATE_VAL : '</schedule_date>'
                        XML.RESPONSE = XML.RESPONSE : '<schedule_qty>' : SCHED_QTY_VAL : '</schedule_qty>'
                        XML.RESPONSE = XML.RESPONSE : '<line_position>' : I : '</line_position>'
                        XML.RESPONSE = XML.RESPONSE : '</schedule_entry>'
                    END
                END
            NEXT J
        END
        XML.RESPONSE = XML.RESPONSE : '</schedule_entries>'
        
        * Add line notes for this line item
        LINE_NOTES_RAW = SO.RECORD<40>
        LINE_NOTE_VAL = FIELD(LINE_NOTES_RAW, XVM, I)
        IF LINE_NOTE_VAL <> '' THEN
            * Convert CHAR(252) subvalue marks to newlines for display
            LINE_NOTE_DISPLAY = LINE_NOTE_VAL
            CONVERT XSM TO CHAR(10) IN LINE_NOTE_DISPLAY
            XML.RESPONSE = XML.RESPONSE : '<line_notes>' : LINE_NOTE_DISPLAY : '</line_notes>'
        END
        
        * Add production notes for this line item (Field 73)
        PROD_NOTES_RAW = SO.RECORD<73>
        PROD_NOTE_VAL = FIELD(PROD_NOTES_RAW, XVM, I)
        IF PROD_NOTE_VAL <> '' THEN
            * Convert CHAR(252) subvalue marks to newlines for display
            PROD_NOTE_DISPLAY = PROD_NOTE_VAL
            CONVERT XSM TO CHAR(10) IN PROD_NOTE_DISPLAY
            XML.RESPONSE = XML.RESPONSE : '<prod_notes>' : PROD_NOTE_DISPLAY : '</prod_notes>'
        END
        
        XML.RESPONSE = XML.RESPONSE : '</line_item>'
    NEXT I
END
XML.RESPONSE = XML.RESPONSE : '</line_items>'

* Essential notes - Convert multivalue separator to newlines for proper display
HEADER_NOTES_RAW = SO.RECORD<25>
CONVERT XVM TO CHAR(10) IN HEADER_NOTES_RAW
CONVERT XSM TO CHAR(10) IN HEADER_NOTES_RAW
XML.RESPONSE = XML.RESPONSE : '<header_notes>' : HEADER_NOTES_RAW : '</header_notes>'
XML.RESPONSE = XML.RESPONSE : '<noted_stamp>' : SO.RECORD<30> : '</noted_stamp>'
PROD_NOTES_DISPLAY = SO.RECORD<73>
CONVERT XSM TO CHAR(10) IN PROD_NOTES_DISPLAY
XML.RESPONSE = XML.RESPONSE : '<production_notes>' : PROD_NOTES_DISPLAY : '</production_notes>'

* Acknowledgments processing (cleaned and parsed) - ONLY field 49
ACK_DATA = SO.RECORD<49>
XML.RESPONSE = XML.RESPONSE : '<acknowledgments>'
IF ACK_DATA <> '' THEN
    * Clean the data first to remove corruption
    CONVERT CHAR(13) TO '' IN ACK_DATA
    CONVERT CHAR(10) TO '' IN ACK_DATA  
    CONVERT 'ý' TO '' IN ACK_DATA
    CONVERT 'Ã' TO '' IN ACK_DATA
    ACK_DATA = TRIM(ACK_DATA)
    
    * Process all acknowledgments from all line items
    ACK_COUNT = DCOUNT(ACK_DATA, XVM)
    FOR ACK_IDX = 1 TO ACK_COUNT
        ACK_LINE_DATA = FIELD(ACK_DATA, XVM, ACK_IDX)
        IF ACK_LINE_DATA <> '' THEN
            ACK_SUB_COUNT = DCOUNT(ACK_LINE_DATA, XSM)
            IF ACK_SUB_COUNT = 0 THEN ACK_SUB_COUNT = 1
            FOR A = 1 TO ACK_SUB_COUNT
                ACK_SUB = FIELD(ACK_LINE_DATA, XSM, A)
                IF ACK_SUB <> '' THEN
                    ACK_DATE_VAL = FIELD(ACK_SUB, '*', 1)
                    ACK_QTY_VAL = FIELD(ACK_SUB, '*', 2)
                    
                    * Clean quantity by extracting only digits
                    CLEAN_ACK_QTY = ''
                    IF ACK_QTY_VAL <> '' THEN
                        ACK_QTY_LEN = LEN(ACK_QTY_VAL)
                        FOR ACK_I = 1 TO ACK_QTY_LEN
                            ACK_CHAR = ACK_QTY_VAL[ACK_I,1]
                            IF ACK_CHAR >= '0' AND ACK_CHAR <= '9' THEN
                                CLEAN_ACK_QTY = CLEAN_ACK_QTY : ACK_CHAR
                            END
                            IF ACK_CHAR < '0' OR ACK_CHAR > '9' THEN ACK_I = ACK_QTY_LEN
                        NEXT ACK_I
                        IF CLEAN_ACK_QTY <> '' THEN ACK_QTY_VAL = CLEAN_ACK_QTY
                    END
                    
                    XML.RESPONSE = XML.RESPONSE : '<ack_entry>'
                    XML.RESPONSE = XML.RESPONSE : '<ack_date>' : ACK_DATE_VAL : '</ack_date>'
                    XML.RESPONSE = XML.RESPONSE : '<ack_qty>' : ACK_QTY_VAL : '</ack_qty>'
                    XML.RESPONSE = XML.RESPONSE : '<line_position>' : I : '</line_position>'
                    XML.RESPONSE = XML.RESPONSE : '</ack_entry>'
                END
            NEXT A
        END
    NEXT ACK_IDX
END
XML.RESPONSE = XML.RESPONSE : '<ack_field49>' : ACK_DATA : '</ack_field49>'
XML.RESPONSE = XML.RESPONSE : '</acknowledgments>'

* Needs info processing - Field 38 with multivalue/subvalue parsing
NEEDS_DATA = SO.RECORD<38>
IF NEEDS_DATA <> '' THEN
    XML.RESPONSE = XML.RESPONSE : '<needs_info>'
    XML.RESPONSE = XML.RESPONSE : '<debug_needs_line_count>' : DCOUNT(NEEDS_DATA, XVM) : '</debug_needs_line_count>'
    
    * Parse multivalue (line items) and subvalue (multiple needs per line)
    NEEDS_LINE_COUNT = DCOUNT(NEEDS_DATA, XVM)
    FOR NEEDS_LINE_IDX = 1 TO NEEDS_LINE_COUNT
        NEEDS_LINE_DATA = FIELD(NEEDS_DATA, XVM, NEEDS_LINE_IDX)
        XML.RESPONSE = XML.RESPONSE : '<debug_line_data>' : NEEDS_LINE_DATA : '</debug_line_data>'
        
        IF NEEDS_LINE_DATA <> '' THEN
            * Parse subvalues (individual need entries within this line)
            NEEDS_SUB_COUNT = DCOUNT(NEEDS_LINE_DATA, XSM)
            IF NEEDS_SUB_COUNT = 0 THEN NEEDS_SUB_COUNT = 1
            XML.RESPONSE = XML.RESPONSE : '<debug_subval_count>' : NEEDS_SUB_COUNT : '</debug_subval_count>'
            
            FOR NEEDS_SUB = 1 TO NEEDS_SUB_COUNT
                NEEDS_SUB_VAL = FIELD(NEEDS_LINE_DATA, XSM, NEEDS_SUB)
                XML.RESPONSE = XML.RESPONSE : '<debug_subval>' : NEEDS_SUB_VAL : '</debug_subval>'
                
                IF NEEDS_SUB_VAL <> '' THEN
                    * Parse date*qty format
                    NEED_DATE = FIELD(NEEDS_SUB_VAL, '*', 1)
                    NEED_QTY = FIELD(NEEDS_SUB_VAL, '*', 2)
                    
                    XML.RESPONSE = XML.RESPONSE : '<debug_parsed_date>' : NEED_DATE : '</debug_parsed_date>'
                    XML.RESPONSE = XML.RESPONSE : '<debug_parsed_qty>' : NEED_QTY : '</debug_parsed_qty>'
                    
                    * Only create entry if we have both date and qty
                    IF NEED_DATE <> '' AND NEED_QTY <> '' THEN
                        XML.RESPONSE = XML.RESPONSE : '<need_entry>'
                        XML.RESPONSE = XML.RESPONSE : '<need_date>' : NEED_DATE : '</need_date>'
                        XML.RESPONSE = XML.RESPONSE : '<need_qty>' : NEED_QTY : '</need_qty>'
                        XML.RESPONSE = XML.RESPONSE : '<line_position>' : NEEDS_LINE_IDX : '</line_position>'
                        XML.RESPONSE = XML.RESPONSE : '</need_entry>'
                    END
                END
            NEXT NEEDS_SUB
        END
    NEXT NEEDS_LINE_IDX
    
    XML.RESPONSE = XML.RESPONSE : '</needs_info>'
END

* Schedule info processing - MINIMAL CLEANING TO PRESERVE ORIGINAL ORDER
SCHED_DATA = SO.RECORD<34>
IF SCHED_DATA <> '' THEN
    XML.RESPONSE = XML.RESPONSE : '<schedule_info>'
    
    * Minimal cleaning - only control characters
    TEMP_SCHED_DATA = SCHED_DATA
    CONVERT CHAR(0) TO '' IN TEMP_SCHED_DATA
    CONVERT CHAR(1) TO '' IN TEMP_SCHED_DATA
    CONVERT CHAR(2) TO '' IN TEMP_SCHED_DATA
    TEMP_SCHED_DATA = TRIM(TEMP_SCHED_DATA)
    
    SCHED_COUNT = DCOUNT(TEMP_SCHED_DATA, XVM)
    FOR SCHED_IDX = 1 TO SCHED_COUNT
        SCHED_MV = FIELD(TEMP_SCHED_DATA, XVM, SCHED_IDX)
        IF SCHED_MV <> '' THEN
            SCHED_SUBCOUNT = DCOUNT(SCHED_MV, XSM)
            IF SCHED_SUBCOUNT = 0 AND SCHED_MV <> '' THEN SCHED_SUBCOUNT = 1
            
            FOR SCHED_SUB = 1 TO SCHED_SUBCOUNT
                SCHED_ITEM = FIELD(SCHED_MV, XSM, SCHED_SUB)
                IF SCHED_ITEM <> '' THEN
                    SCHED_DATE = FIELD(SCHED_ITEM, '*', 1)
                    SCHED_QTY = FIELD(SCHED_ITEM, '*', 2)
                    
                    * CRITICAL: Filter out invalid Julian dates like "1", "0", etc.
                    SKIP_INVALID_DATE = 0
                    IF NUM(SCHED_DATE) AND SCHED_DATE <> '' THEN
                        IF SCHED_DATE < 365 THEN
                            SKIP_INVALID_DATE = 1
                            * Debug: Log filtered dates
                            XML.RESPONSE = XML.RESPONSE : '<!-- FILTERED INVALID DATE: ' : SCHED_DATE : ' -->'
                        END
                    END
                    
                    * Debug: Log processing decision
                    XML.RESPONSE = XML.RESPONSE : '<!-- PROCESSING DATE: ' : SCHED_DATE : ' SKIP=' : SKIP_INVALID_DATE : ' -->'
                    
                    * Only process valid dates
                    IF SKIP_INVALID_DATE = 0 THEN
                        * Preserve original quantities with minimal cleaning
                        IF SCHED_QTY <> '' THEN
                            SCHED_QTY = TRIM(SCHED_QTY)
                            * Only clean obvious Julian date corruption
                            IF LEN(SCHED_QTY) > 5 AND INDEX(SCHED_QTY, '20994', 1) > 0 THEN
                                TEMP_QTY = FIELD(SCHED_QTY, '20994', 1)
                                IF TEMP_QTY <> '' AND NUM(TEMP_QTY) THEN
                                    SCHED_QTY = TEMP_QTY
                                END
                            END
                        END
                        
                        XML.RESPONSE = XML.RESPONSE : '<schedule_entry>'
                        XML.RESPONSE = XML.RESPONSE : '<schedule_date>' : SCHED_DATE : '</schedule_date>'
                        XML.RESPONSE = XML.RESPONSE : '<schedule_qty>' : SCHED_QTY : '</schedule_qty>'
                        XML.RESPONSE = XML.RESPONSE : '<line_position>' : I : '</line_position>'
                        XML.RESPONSE = XML.RESPONSE : '</schedule_entry>'
                    END
                END
            NEXT SCHED_SUB
        END
    NEXT SCHED_IDX
    XML.RESPONSE = XML.RESPONSE : '</schedule_info>'
END

* CRITICAL FIX: Add global needs_info section for frontend
NEEDS_FIELD_38 = SO.RECORD<38>
XML.RESPONSE = XML.RESPONSE : '<debug_needs_field38>[' : NEEDS_FIELD_38 : ']</debug_needs_field38>'
IF NEEDS_FIELD_38 <> '' THEN
    XML.RESPONSE = XML.RESPONSE : '<needs_info>'
    NEEDS_LINE_COUNT = DCOUNT(NEEDS_FIELD_38, XVM)
    XML.RESPONSE = XML.RESPONSE : '<debug_needs_line_count>' : NEEDS_LINE_COUNT : '</debug_needs_line_count>'
    FOR NEEDS_LINE_IDX = 1 TO NEEDS_LINE_COUNT
        NEEDS_LINE_DATA = FIELD(NEEDS_FIELD_38, XVM, NEEDS_LINE_IDX)
        XML.RESPONSE = XML.RESPONSE : '<debug_line_data>' : NEEDS_LINE_DATA : '</debug_line_data>'
        IF NEEDS_LINE_DATA <> '' THEN
            * Process subvalues within this line
            NEEDS_SUBVAL_COUNT = DCOUNT(NEEDS_LINE_DATA, XSM)
            XML.RESPONSE = XML.RESPONSE : '<debug_subval_count>' : NEEDS_SUBVAL_COUNT : '</debug_subval_count>'
            FOR NEEDS_SUB_IDX = 1 TO NEEDS_SUBVAL_COUNT
                NEEDS_SUBVAL = FIELD(NEEDS_LINE_DATA, XSM, NEEDS_SUB_IDX)
                XML.RESPONSE = XML.RESPONSE : '<debug_subval>' : NEEDS_SUBVAL : '</debug_subval>'
                IF NEEDS_SUBVAL <> '' THEN
                    NEEDS_DATE_GLOBAL = FIELD(NEEDS_SUBVAL, '*', 1)
                    NEEDS_QTY_GLOBAL = FIELD(NEEDS_SUBVAL, '*', 2)
                    
                    * CRITICAL FIX: Clean global need date from line index prefix
                    IF INDEX(NEEDS_DATE_GLOBAL, ':', 1) > 0 THEN
                        COLON_COUNT = DCOUNT(NEEDS_DATE_GLOBAL, ':')
                        NEEDS_DATE_GLOBAL = FIELD(NEEDS_DATE_GLOBAL, ':', COLON_COUNT)
                    END
                    
                    * CRITICAL FIX: Clean global need quantity from date contamination
                    IF INDEX(NEEDS_QTY_GLOBAL, '2025', 1) > 0 THEN
                        NEEDS_QTY_GLOBAL = FIELD(NEEDS_QTY_GLOBAL, '2025', 1)
                    END
                    IF INDEX(NEEDS_QTY_GLOBAL, '-', 1) > 0 THEN
                        NEEDS_QTY_GLOBAL = FIELD(NEEDS_QTY_GLOBAL, '-', 1)  
                    END
                    IF INDEX(NEEDS_QTY_GLOBAL, '\', 1) > 0 THEN
                        NEEDS_QTY_GLOBAL = FIELD(NEEDS_QTY_GLOBAL, '\', 1)
                    END
                    NEEDS_QTY_GLOBAL = TRIM(NEEDS_QTY_GLOBAL)
                    
                    XML.RESPONSE = XML.RESPONSE : '<debug_parsed_date>' : NEEDS_DATE_GLOBAL : '</debug_parsed_date>'
                    XML.RESPONSE = XML.RESPONSE : '<debug_parsed_qty>' : NEEDS_QTY_GLOBAL : '</debug_parsed_qty>'
                    IF NEEDS_DATE_GLOBAL <> '' AND NEEDS_QTY_GLOBAL <> '' THEN
                        XML.RESPONSE = XML.RESPONSE : '<need_entry>'
                        XML.RESPONSE = XML.RESPONSE : '<need_date>' : NEEDS_DATE_GLOBAL : '</need_date>'
                        XML.RESPONSE = XML.RESPONSE : '<need_qty>' : NEEDS_QTY_GLOBAL : '</need_qty>'
                        XML.RESPONSE = XML.RESPONSE : '<line_position>' : NEEDS_LINE_IDX : '</line_position>'
                        XML.RESPONSE = XML.RESPONSE : '</need_entry>'
                    END
                END
            NEXT NEEDS_SUB_IDX
        END
    NEXT NEEDS_LINE_IDX
    XML.RESPONSE = XML.RESPONSE : '</needs_info>'
END

* Line notes processing with contamination debug
LINE_NOTES_DATA = SO.RECORD<40>
XML.RESPONSE = XML.RESPONSE : '<!-- DEBUG_FIELD_40_RAW: [' : LINE_NOTES_DATA : '] -->'
XML.RESPONSE = XML.RESPONSE : '<!-- DEBUG_FIELD_40_LENGTH: [' : LEN(LINE_NOTES_DATA) : '] -->'
XML.RESPONSE = XML.RESPONSE : '<!-- DEBUG_FIELD_40_CONTAINS_ASTERISK: [' : (INDEX(LINE_NOTES_DATA, '*', 1) > 0) : '] -->'
XML.RESPONSE = XML.RESPONSE : '<!-- DEBUG_FIELD_40_CONTAINS_BACKSLASH: [' : (INDEX(LINE_NOTES_DATA, '\', 1) > 0) : '] -->'
IF LINE_NOTES_DATA <> '' THEN
    XML.RESPONSE = XML.RESPONSE : '<line_notes>'
    NOTES_COUNT = DCOUNT(LINE_NOTES_DATA, XVM)
    FOR NOTES_IDX = 1 TO NOTES_COUNT
        NOTE_ENTRY = FIELD(LINE_NOTES_DATA, XVM, NOTES_IDX)
        IF NOTE_ENTRY <> '' THEN
            XML.RESPONSE = XML.RESPONSE : '<line_note>'
            XML.RESPONSE = XML.RESPONSE : '<note>' : NOTE_ENTRY : '</note>'
            XML.RESPONSE = XML.RESPONSE : '</line_note>'
        END
    NEXT NOTES_IDX
    XML.RESPONSE = XML.RESPONSE : '</line_notes>'
END

* Buyer info lookup
SALESPERSON_CODE = SO.RECORD<8>
IF SALESPERSON_CODE <> '' THEN
    XML.RESPONSE = XML.RESPONSE : '<salesperson_info>'
    XML.RESPONSE = XML.RESPONSE : '<salesperson_code>' : SALESPERSON_CODE : '</salesperson_code>'
    XML.RESPONSE = XML.RESPONSE : '<salesperson_name></salesperson_name>'
    XML.RESPONSE = XML.RESPONSE : '<salesperson_email></salesperson_email>'
    XML.RESPONSE = XML.RESPONSE : '<salesperson_initials>' : SALESPERSON_CODE : '</salesperson_initials>'
    XML.RESPONSE = XML.RESPONSE : '</salesperson_info>'
END

XML.RESPONSE = XML.RESPONSE : '<status>found</status></so></salesorders>'

WRITE_RESPONSE:
WRITE XML.RESPONSE ON XMLDATAF,'GET_SO.XML'
ERR = ''
CALL PLW.PAGE('/XMLDATA/GET_SO.XML','',ERR)
RETURN

* Subroutine to clean special characters for XML output
CLEAN_TEXT:
    * Replace Attribute Marks (CHAR(254)) with spaces
    CONVERT CHAR(254) TO ' ' IN CLEAN_STR
    * Replace Value Marks (CHAR(253)) with spaces  
    CONVERT CHAR(253) TO ' ' IN CLEAN_STR
    * Replace Subvalue Marks (CHAR(252)) with spaces
    CONVERT CHAR(252) TO ' ' IN CLEAN_STR
    * Remove control characters
    CONVERT CHAR(0) TO '' IN CLEAN_STR
    CONVERT CHAR(1) TO '' IN CLEAN_STR
    CONVERT CHAR(2) TO '' IN CLEAN_STR
    * Trim leading/trailing spaces and compress multiple spaces
    CLEAN_STR = TRIM(CLEAN_STR)
RETURN
</PRE>
